---
title: "Download base data from BC data catalogue"
author: "Matt Coghill and Gen Perkins"
script author: "Matt Coghill"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r read libraries}
checkpoint::setSnapshot(Sys.Date())
ls <- c("bcdata", "bcmaps", "sf", "tidyverse", "raster", "stars")
github_ls <- c("bcmapsdata")
new_packages <- ls[!(ls %in% installed.packages()[, "Package"])]
github_new_packages <- github_ls[!(github_ls %in% installed.packages()[, "Package"])]
if(length(new_packages))
  install.packages(new_packages)
if(length(github_new_packages))
  install.packages('bcmapsdata', repos='https://bcgov.github.io/drat/')
ls <- c(ls, github_ls)
lapply(ls, library, character.only = TRUE)
rm(ls, new_packages, github_ls, github_new_packages)

```

## Overview 

This script downloads the relevant spatial data for BEC zones, VRI, TEM, waterbodies and the road network used in stage 1 of PEM processing. Data is downloaded directly from the [BC Data Catalogue](https://catalogue.data.gov.bc.ca/dataset?download_audience=Public) using the [bcdata](https://github.com/bcgov/bcdata) package.

### Datasets to download 

* BEC - [Biogeoclimatic Ecosystems Classification](https://catalogue.data.gov.bc.ca/dataset/bec-map) are used to define and/or select specific "subzones" within a defined study area. 

* Vegetation Resource Inventory (VRI) - This layer includes a variety of vegetation measure, including cutblock age, TEM data and ..... Detailed data standards can be found [here](https://www2.gov.bc.ca/gov/content/industry/forestry/managing-our-forest-resources/forest-inventory/data-management-and-access/vri-data-standards).  

* Freshwater Atlas -  The atlas is separated into the different types of waterbodies (lakes, rivers, wetlands, streams, man made, etc.), which requires a seperate download per type. Alternatively a single combined layer can be downloaded by is limited to linear data type. A parameter within the function can be set to "polygon" (the default option) or "linear".  

* Road network 




## Work-flow

This script relies on having a spatial file (AOI.gpkg) defining the study area (area of interest - AOI). Firstly the area of interest is defined along with input and output folders. 

Where a subset of the study area is being used (ie. by subzone), a character string is used to define the subzone(s) of interest. The default value (NULL) will include all subzones. 


```{r Parameters}
AOI <- "Sechelt"
AOI_dir <- file.path(".", paste0(AOI, "_AOI"))

# Options and parameters
map_res <- 4 # Only used to help locate input files below
subzones <- c("IDFxh2", "IDFdk1") # Filter results to only include subzones of interest
                                  # set to NULL or don't run it if you want the full area

```

A single function is used to download BEC zone info, VRI shapes, TEM shapes (if applicable), water bodies, and roads all in one go. Each is clipped to the extent of the study area at each resolution, though this may not be very efficient. 

```{r Function}
get_bc_shapes <- function(in_aoi = NULL, 
  out_path = NULL, 
  subzones = NULL, 
  update_raster_extents = FALSE, 
  raster_files = NULL, 
  epsg = 3005) 
  {
  #### Input checks
  if(is.null(in_aoi) || 
     (!is.null(in_aoi) && !class(in_aoi) %in% c("character", "sf"))) {
    stop("You must provide a valid AOI either as a shape or a file path to a shape")
  } else if(!is.null(in_aoi) && is.character(in_aoi)) {
    study_area <- st_read(in_aoi)
  } else if(!is.null(in_aoi) && class(in_aoi) %in% "sf") {
    study_area <- in_aoi
  }
  
  if(is.null(out_path)) {
    out_path <- dirname(in_aoi)
  } else if(!is.null(out_path) && !is.character(out_path)) {
    stop("out_path is an invalid file path string")
  }
  
  if(!is.null(subzones) && !is.character(subzones)) {
    stop("Subzone filter should be a character string representing the subzones to keep")
  }
  
  if(!is.null(raster_files) && !is.character(raster_files)) {
    stop("File paths to raster files need to be provided")
  }
  
  if(is.null(update_raster_extents)) {
    update_raster_extents <- FALSE
  } else if(!is.null(update_raster_extents) && !is.logical(update_raster_extents)) {
    stop("update_raster_extents requires a logical input (TRUE or FALSE)")
  } else if(is.null(subzones) && isTRUE(update_raster_extents)) {
    update_raster_extents <- FALSE
    message("\nNo subzones selected, raster extents will not be updated")
  } else if(is.null(raster_files) && isTRUE(update_raster_extents)) {
    message("\nNo raster files to update")
  }
  
  #### Function script
  # Set or transform CRS of input AOI if not provided
  if(is.na(st_crs(study_area)$proj4string)) {
    message(paste0("No CRS detected for in_aoi, setting to EPSG ", epsg))
    study_area <- st_set_crs(study_area, epsg)
  } else if(st_crs(study_area)$proj4string != st_crs(epsg)$proj4string) {
    study_area <- st_transform(study_area, epsg)
  }
  
  # Adjust max download size based on AOI
  options(bcdata.max_geom_pred_size = as.numeric(st_area(study_area)) + 10)
  
  # Download BEC, transform if necessary, and clip to AOI
  message("\nDownloading BEC layer")
  bec_sf <- bec(class = "sf")
  if(st_crs(bec_sf)$proj4string != st_crs(study_area)$proj4string) {
    bec_sf <- st_transform(bec_sf, epsg) %>% 
      st_intersection(study_area)
  } else {
    bec_sf <- st_intersection(bec_sf, study_area)
  }
  
  # Update BEC zone layer to only include subzones of interest
  if(!is.null(subzones)) {
    bec_sf <- dplyr::filter(bec_sf, as.character(MAP_LABEL) %in% subzones)
    study_area <- st_intersection(study_area, bec_sf) %>% 
      summarise()
    st_write(study_area, file.path(out_path, "aoi.gpkg"), delete_dsn = TRUE, delete_layer = TRUE)
  }
  st_write(bec_sf, file.path(out_path, "bec.gpkg"), delete_dsn = TRUE, delete_layer = TRUE)
  
  # Download VRI
  message("\nDownloading VRI layer")
  vri <- bcdc_query_geodata("2ebb35d8-c82f-4a17-9c96-612ac3532d55", crs = epsg) %>% 
    bcdata::filter(INTERSECTS(study_area)) %>% 
    bcdata::select(c("BCLCS_LEVEL_2")) %>% # Treed sites
    collect() %>% 
    {if(nrow(.) > 0){st_intersection(., study_area)} else .}
  st_write(vri, file.path(out_path, "vri.gpkg"), delete_dsn = TRUE, delete_layer = TRUE)
  #st_write(vri, file.path(out_path, "vri.shp"), delete_dsn = TRUE, delete_layer = TRUE)
  
  # Download recent cutblocks layer
  # Uses date filter which filters cutblock ages less than 20 years, or 7305 days
  message("\nDownloading cutblock layer")
  cutblocks <- bcdc_query_geodata("b1b647a6-f271-42e0-9cd0-89ec24bce9f7", crs = epsg) %>% 
    bcdata::filter(INTERSECTS(study_area)) %>% 
    collect() %>% 
    {if(nrow(.) > 0){st_intersection(., study_area)} else .} %>% 
    mutate(DISTURBANCE_START_DATE = as.Date(DISTURBANCE_START_DATE),
           DISTURBANCE_END_DATE = as.Date(DISTURBANCE_END_DATE)) %>% 
    dplyr::filter(Sys.Date() - DISTURBANCE_END_DATE < 7305)
  st_write(cutblocks, file.path(out_path, "cutblocks.gpkg"), delete_dsn = TRUE, delete_layer = TRUE)
  #st_write(cutblocks, file.path(out_path, "cutblocks.shp"), delete_dsn = TRUE, delete_layer = TRUE)
  
  # Download TEM
  "\nDownloading TEM layer"
  tem <- bcdc_query_geodata("0a83163b-a62f-4ce6-a9a1-21c228b0c0a3", crs = epsg) %>%
    bcdata::filter(INTERSECTS(study_area)) %>%
    collect() %>% 
    {if(nrow(.) > 0){st_intersection(., study_area)} else .}
  st_write(tem, file.path(out_path, "tem.gpkg"), delete_dsn = TRUE, delete_layer = TRUE)
  #st_write(tem, file.path(out_path, "tem.shp"), delete_dsn = TRUE, delete_layer = TRUE)
  
  # Download water layers, requires merging multiple layers
  message("\nDownloading water layers")
  waterbodies <- study_area[0, ] # creates an empty sf dataframe
  waterbodies <- bcdc_query_geodata("cb1e3aba-d3fe-4de1-a2d4-b8b6650fb1f6", crs = epsg) %>% # lakes
    bcdata::filter(INTERSECTS(study_area)) %>% 
    collect() %>% {if(nrow(.) > 0){rbind(., waterbodies)} else waterbodies}
  waterbodies <- bcdc_query_geodata("f7dac054-efbf-402f-ab62-6fc4b32a619e", crs = epsg) %>% # rivers
    bcdata::filter(INTERSECTS(study_area)) %>% 
    collect() %>% {if(nrow(.) > 0){rbind(., waterbodies)} else waterbodies}
  waterbodies <- bcdc_query_geodata("93b413d8-1840-4770-9629-641d74bd1cc6", crs = epsg) %>% # wetlands
    bcdata::filter(INTERSECTS(study_area)) %>% 
    collect() %>% {if(nrow(.) > 0){rbind(., waterbodies)} else waterbodies}
  
  water_clipped <- st_intersection(waterbodies, study_area) 
  st_write(water_clipped, file.path(out_path, "water.gpkg"), delete_dsn = TRUE, delete_layer = TRUE)
  #st_write(water_clipped, file.path(out_path, "water.shp"), delete_dsn = TRUE, delete_layer = TRUE)
  
  # Download road network
  message("\nDownloading Road network")
  roads <- bcdc_query_geodata("bb060417-b6e6-4548-b837-f9060d94743e", crs = epsg) %>% 
    bcdata::filter(INTERSECTS(study_area)) %>% 
    collect() %>% 
    {if(nrow(.) > 0){st_intersection(., study_area)} else .}
  st_write(roads, file.path(out_path, "road_network.gpkg"), delete_dsn = TRUE, delete_layer = TRUE)
  #st_write(roads, file.path(out_path, "road_network.shp"), delete_dsn = TRUE, delete_layer = TRUE)
  
  # Mask raster files with updated BEC shape
  # It would be better to functionize this using the terra package
  # though I ran into issues during testing (it would always crash).
  if(isTRUE(update_raster_extents) && !is.null(subzones)) {
    message("\nUpdating raster shapes")
    in_stack <- stack()
    for(i in raster_files) {
      r <- raster(i)
      if(projection(r) != st_crs(epsg)$proj4string) {
        projection(r) <- st_crs(epsg)$proj4string
      }
      in_stack <- stack(in_stack, r)
    }
    m <- mask(in_stack, study_area)
    writeRaster(m, filename = file.path(dirname(i[1]), names(m)), 
                bylayer = TRUE, format = "GTiff", overwrite = TRUE)
  }
  output <- list.files(out_path, pattern = ".gpkg", full.names = TRUE)
}
```

We can define the parameters and run the above function.

```{r Run Functions}
res_name <- paste0(map_res, "m")

# Define the input AOI file
in_aoi <- file.path(
  AOI_dir, "0_raw_inputs", "base_layers", res_name, "aoi.gpkg")

# Define output file path for downloaded shapes (function will default
# to the folder of in_aoi)
out_path <- dirname(in_aoi)

# If masking rasters due to the AOI changing from the BEC, list the
# appropriate rasters here. Below, I've included a file pattern
# that will find LiDAR derived files created from the 01_LiDAR script

download_shapes <- get_bc_shapes(in_aoi = in_aoi, 
  out_path = out_path, 
  subzones = NULL, 
  update_raster_extents = FALSE)

## Can throw the whole chunk above into a loop to get exact clipping boundaries for multiple resolutions
```

* Accessing the [consolidated cutblock layer](https://catalogue.data.gov.bc.ca/dataset/harvested-areas-of-bc-consolidated-cutblocks-) using the bcdata package 

* Using satelite imagery to identify recent cutblocks (this can also be used to mask large waterbodies. ).
