---
title: "02c_Models"
author: "Matthew Coghill"
date: "2/19/2020"
output: html_document
---

This document is meant to generate models and predictions of either binary classification of presence / absence, or regression models of plant cover. This script should be the last script ran in the whole process as it depends on:

1. Covariate layers generated in 01 scripts;
2. Proper datasets generated in the 02a script; and
3. The site series raster generated in the 02b script.

This script uses the mlr3 package (machine learning R) in order to make models. It's very powerful and can evaluate a lot of different models at the same time. I'll attempt to explain things each step of the way. First, we will load the packages used in this script.

```{r Load Packages}

ls <- c("tidyverse", "tools", "terra", "sf", "ranger", "mlr3verse", "parallel", 
        "parallelMap", "randomForest", "ModelMap", "foreach", "gdalUtils")
new.packages <- ls[!(ls %in% installed.packages()[, "Package"])]
if(length(new.packages))
  install.packages(new.packages)
lapply(ls, library, character.only = TRUE)[0]
rm(ls, new.packages)

source("./_functions/model_gen_mlr3.R")
source("./_functions/predict_landscape_mlr3.R")

```

Next, directories and certain files are defined.

```{r Define directories}

AOI <- "Sechelt"
AOI_dir <- file.path(".", paste0(AOI, "_AOI"))
map_res <- 4

input_dir <- file.path("./Sechelt_AOI/1_map_inputs/field_data/processed")
covariate_dir <- file.path(AOI_dir, "1_map_inputs", "covariates")
ss_dir <- file.path(AOI_dir, "1_map_inputs", "dsmart", "output")
output_dir <- file.path(AOI_dir, "2_map_predictions")
tile_dir <- file.path(output_dir, "tiles")
dir.create(tile_dir, showWarnings = FALSE)
dir.create(file.path(output_dir, "pres_abs_predictions"), showWarnings = FALSE)
dir.create(file.path(output_dir, "cover_predictions"), showWarnings = FALSE)

ss <- "dsmart" # The two options are currently simple or dsmart

```

It is highly anticipated that a site series layer will have a high degree of importance in predicting the locations of these culturally sensitive plants. We will let the models decide whether that is true or not, but it is possible to always be kept in the model by defining one of the options (not incorporated here).

The only step in this script that requires you changing anything is the first line, model_run. Change this parameter to be whatever model you want to generate results for. Cover models will be a regression and presence / absence models will be a classification.

The mlr package creates models using building blocks called "tasks" and "learners". Tasks are essentially the data you are creating your models from, and learners are more specific to building models. For example, the first learner that's created here says "create a ranger regression model, and when creating the model rank importance variables by their impurity values. Also, this is a response model". The next learner is a feature selection filter which wraps around the first learner. It pretty much says that it will filter the variables using the ranger_impurity algorithm, but always will keep the site_series layer. The last learner is a parameter tuning algorithm wrapped around the feature selection filter, and gives further details on the model. It will be a spatial 10-fold cross validation repeated 5 times. Also, it will create models using different amounts of covariate layers and numbers of trees so that it selects the best model from that bunch.

After mlr fits the best model, that model is extracted and the predictions for presence / absence or cover are created. This can take some time depending on the amount of predictor variables used in the final model. Finally, some zonal statistics are calculated per site series.

```{r Load data}

res_folder <- paste0(map_res, "m")

# Raster covariates
terrain_covariates <- grep(pattern = "normal|sentinel2", list.files(
  file.path(covariate_dir, res_folder), full.names = TRUE, pattern = ".tif$"), invert = TRUE, 
  value = TRUE)
sentinel_covariates <- list.files(file.path(covariate_dir, res_folder), 
                                  pattern = "^sentinel2.*.summer.tif$", full.names = TRUE)
climate_covariates <- list.files(file.path(covariate_dir, res_folder), 
                                 pattern = "^normal.*._sm.tif$", full.names = TRUE)
site_series <- list.files(ss_dir, pattern = "site_series_.*..tif", full.names = TRUE)
covariates <- rast(c(terrain_covariates, sentinel_covariates, climate_covariates, site_series))

# Attributed point data
pres_abs_points <- sapply(st_layers(file.path(input_dir, "pres_abs.gpkg"))$name, function(x) {
  st_read(file.path(input_dir, "pres_abs.gpkg"), layer = x, quiet = TRUE) %>% 
    cbind(st_coordinates(.), terra::extract(rast(site_series), st_coordinates(.))) %>% 
    st_drop_geometry() %>% 
    mutate(Pres = as.factor(Pres)) %>% 
    dplyr::select(Pres, names(covariates), X, Y)
  }, simplify = FALSE, USE.NAMES = TRUE)
cover_points <- sapply(st_layers(file.path(input_dir, "cover.gpkg"))$name, function(x) {
  st_read(file.path(input_dir, "cover.gpkg"), layer = x, quiet = TRUE) %>% 
    cbind(st_coordinates(.), terra::extract(rast(site_series), st_coordinates(.))) %>% 
    st_drop_geometry() %>% 
    dplyr::select(Cover, names(covariates), X, Y)
  }, simplify = FALSE, USE.NAMES = TRUE)

# Find the best masking layer to use in the predict_landscape algorithm
mask_layer <- foreach(i = 1:nlyr(covariates), .combine = rbind) %do% {
    cat(paste0("Counting NA values in ", names(covariates[[i]]), 
               " [", i, " of ", nlyr(covariates), "]\n"))
    new <- subset(covariates, i) * 0
    data.frame(layer = names(new), 
               data_cells = data.frame(freq(new))$count)
  } %>% mutate(data_cells = ifelse(data_cells == ncell(new), 0, data_cells)) %>% 
    dplyr::slice(which.max(data_cells))

```




```{r mlr3 pres/abs probability modelling}

# Use mlr3 to create the best models
# The function does everything needed and outputs a list of the best models
# for each plant species. Function uses mlr3 to do 10 fold cross validaion
# repeated 5 times for each iteration of the model. There are 10 iterations which
# are different combinations of covariate layers (in attempts to find the best 
# feature set). This results in 500 models per species. The function is also aware
# of what the prediction types should be: for pres/abs, we want a probability 
# output from classification modelling, whereas for cover we want the raw 
# predictions created from regression modelling

# To assess how useful the TEM is, I've made different models using a simiple
# rasterized version, the DSMART version, and models that don't use it as well.
pres_abs <- c(
  sapply(paste0(names(pres_abs_points), "_no_tem"), function(x) {
    y <- gsub("_no_tem", "", x)
    dplyr::select(pres_abs_points[[y]], -c(site_series_dsmart, site_series_simple)) %>% 
      drop_na()
    }, simplify = FALSE, USE.NAMES = TRUE),
  sapply(paste0(names(pres_abs_points), "_simple_tem"), function(x) {
    y <- gsub("_simple_tem", "", x)
    dplyr::select(pres_abs_points[[y]], -site_series_dsmart) %>% 
      drop_na()
    }, simplify = FALSE, USE.NAMES = TRUE), 
  sapply(paste0(names(pres_abs_points), "_dsmart_tem"), function(x) {
    y <- gsub("_dsmart_tem", "", x)
    dplyr::select(pres_abs_points[[y]], -site_series_simple) %>% 
      drop_na()
    }, simplify = FALSE, USE.NAMES = TRUE))

# Write input data
lapply(names(pres_abs), function(x) {
  dir_out <- file.path(output_dir, "pres_abs_predictions")
  dir.create(dir_out, showWarnings = FALSE)
  y <- st_as_sf(pres_abs[[x]], coords = c("X", "Y"), crs = crs(covariates))
  st_write(y, file.path(dir_out, paste0("pres_abs_input_data.gpkg")), layer = x, delete_layer = TRUE)
  return(invisible())
})

# Run the models. Each is a 10-fold spatial cross validation repeated 5 times
if(!file.exists(file.path(output_dir, "pres_abs_predictions", "pres_abs_models.RDS"))) {
  pres_models <- model_gen_mlr3(traindat = pres_abs, target = "Pres", feature_selection = "filter", type = "prob")
  saveRDS(pres_models, file.path(output_dir, "pres_abs_predictions", "pres_abs_models.RDS"))
} else pres_models <- readRDS(file.path(output_dir, "pres_abs_predictions", "pres_abs_models.RDS"))

# Extract performance metrics
pres_performance <- sapply(names(pres_models$learners), function(x) {
  
  dir_out <- file.path(output_dir, "pres_abs_predictions", x)
  dir.create(dir_out, showWarnings = FALSE)
  
  tune_results <- data.frame(
    filter_fraction = sapply(pres_models$learners[[x]]$archive()$tune_x, function(x)
    x[[1]]), 
    classif.ce = pres_models$learners[[x]]$archive()$classif.ce
  )
  
  confusion <- as.data.frame(
    pres_models$learners[[x]]$model$tuning_instance$best()$prediction()$confusion)
  
  # There were no rep and fold ID's in the table so I had to create them from scratch
  folds_reps <- sapply(
    pres_models$learners[[x]]$model$tuning_instance$best()$data$prediction, 
    function(x) 
      nrow(x$test$data$tab))

  row_ids <- foreach(i = 1:length(folds_reps), .combine = c) %do% {
    folds <- as.character(i)
    if(nchar(folds) > 1) folds <- substring(folds, 2)
    if(folds == "0") folds <- "10"
    
    reps <- ifelse(i %in% 1:10, 1, ifelse(i %in% 11:20, 2, ifelse(
      i %in% 21:30, 3, ifelse(i %in% 31:40, 4, 5))))
    return(rep(paste0(folds, "_", reps), length.out = folds_reps[i]))
  }
  
  test_data <- as.data.frame(
    pres_models$learners[[x]]$model$tuning_instance$best()$data$resampling[[1]]$instance) %>% 
    mutate(row_id = paste0(row_id, "_", fold, "_", rep)) %>% 
    merge(cbind(
      pres_models$learners[[x]]$model$tuning_instance$best()$prediction()$data$tab %>% 
        mutate(row_id = paste0(row_id, "_", row_ids)),
      pres_models$learners[[x]]$model$tuning_instance$best()$prediction()$data$prob))
  
  imp <- data.frame(pres_models$learners[[x]]$learner$model$classif.ranger$model$variable.importance) %>% 
    rownames_to_column() %>% 
    dplyr::rename_at(vars(names(.)), ~c("layer", "importance")) %>% 
    arrange(desc(importance))
  
  out <- utils::capture.output(pres_models$learners[[x]]$learner$model$classif.ranger$model)
  best_model <- pres_models$learners[[x]]$learner$model$classif.ranger$model
  
  write.csv(tune_results, file = file.path(dir_out, paste0(x, "_tune_results.csv")),
            row.names = FALSE)
  cat(out, file = file.path(dir_out, paste0(x, "_model.txt")), append = TRUE)
  save(best_model, file = file.path(dir_out, paste0(x, "_model.RData")))
  write.csv(test_data, file = file.path(dir_out, paste0(x, "_model_resampling.csv")), 
            row.names = FALSE)
  write.csv(confusion, file = file.path(dir_out, paste0(x, "_confusion.csv")), 
            row.names = FALSE)
  write.csv(imp, file.path(dir_out, paste0(x, "_pres_abs_var_importance.csv")), 
            row.names = FALSE)
  write.csv(pres_abs[[x]], file.path(dir_out, paste0(x, "_input_data.csv")), 
            row.names = FALSE)
  
  return(list(
    tune_results = tune_results,
    best_model = best_model, 
    resampling = test_data,
    confusion = confusion,
    importance = imp
  ))
  
}, simplify = FALSE, USE.NAMES = TRUE)

# Run the map predictions
pres_abs_predictions <- sapply(names(pres_models$learners), function(x) {
  
  dir_out <- file.path(output_dir, "pres_abs_predictions", x)
  dir.create(dir_out, showWarnings = FALSE)
  cov_sub <- subset(cov_raster, pres_models$tasks[[x]]$col_roles$feature)
  
  out <- predict_landscape_mlr3(
    learner = pres_models$learners[[x]],
    task = pres_models$tasks[[x]], 
    type = "prob",
    covariates = cov_sub,
    tilesize = 500, 
    outDir = tile_dir, 
    mask_layer = mask_layer$layer
  )
  
  # with predict_landscape_mlr3 type set to "prob", the output is a list of files
  for(j in out) {
    file.copy(
      from = j,
      to = file.path(dir_out, paste0(x, "_", basename(j))),
      overwrite = TRUE)
  }
  return(out)
}, simplify = FALSE, USE.NAMES = TRUE)

```

```{r mlr3 cover modelling}

# Use mlr3 to create the best models
cover <- c(
  sapply(paste0(names(cover_points), "_no_tem"), function(x) {
    y <- gsub("_no_tem", "", x)
    dplyr::select(cover_points[[y]], -c(site_series_dsmart, site_series_simple)) %>% 
      drop_na()
    }, simplify = FALSE, USE.NAMES = TRUE),
  sapply(paste0(names(cover_points), "_simple_tem"), function(x) {
    y <- gsub("_simple_tem", "", x)
    dplyr::select(cover_points[[y]], -site_series_dsmart) %>% 
      drop_na()
    }, simplify = FALSE, USE.NAMES = TRUE), 
  sapply(paste0(names(cover_points), "_dsmart_tem"), function(x) {
    y <- gsub("_dsmart_tem", "", x)
    dplyr::select(cover_points[[y]], -site_series_simple) %>% 
      drop_na()
    }, simplify = FALSE, USE.NAMES = TRUE))

# Write input data
lapply(names(cover), function(x) {
  dir_out <- file.path(output_dir, "cover_predictions")
  dir.create(dir_out, showWarnings = FALSE)
  y <- st_as_sf(cover[[x]], coords = c("X", "Y"), crs = crs(covariates))
  st_write(y, file.path(dir_out, paste0("cover_input_data.gpkg")), layer = x, delete_layer = TRUE)
  return(invisible())
})

# Run the models. Each is a 10-fold spatial cross validation repeated 5 times
if(!file.exists(file.path(output_dir, "cover_predictions", "cover_models.RDS"))) {
  cover_models <- model_gen_mlr3(traindat = cover, target = "Cover", feature_selection = "filter", type = "response")
  saveRDS(cover_models, file.path(output_dir, "cover_predictions", "cover_models.RDS"))
} else cover_models <- readRDS(file.path(output_dir, "cover_predictions", "cover_models.RDS"))

# Extract performance metrics for each model
cover_performance <- sapply(names(cover_models$learners), function(x) {
  
  dir_out <- file.path(output_dir, "cover_predictions", x)
  dir.create(dir_out, showWarnings = FALSE)
  
  tune_results <- data.frame(
    filter_fraction = sapply(cover_models$learners[[x]]$archive()$tune_x, function(x)
    x[[1]]), 
    regr.mse = cover_models$learners[[x]]$archive()$regr.mse
  )
  
  # There were no rep and fold ID's in the table so I had to create them from scratch
  folds_reps <- sapply(
    cover_models$learners[[x]]$model$tuning_instance$best()$data$prediction, 
    function(x) 
      nrow(x$test$data$tab))

  row_ids <- foreach(i = 1:length(folds_reps), .combine = c) %do% {
    folds <- as.character(i)
    if(nchar(folds) > 1) folds <- substring(folds, 2)
    if(folds == "0") folds <- "10"
    
    reps <- ifelse(i %in% 1:10, 1, ifelse(i %in% 11:20, 2, ifelse(
      i %in% 21:30, 3, ifelse(i %in% 31:40, 4, 5))))
    return(rep(paste0(folds, "_", reps), length.out = folds_reps[i]))
  }
  
  test_data <- as.data.frame(
    cover_models$learners[[x]]$model$tuning_instance$best()$data$resampling[[1]]$instance) %>% 
    mutate(row_id = paste0(row_id, "_", fold, "_", rep)) %>% 
    merge(cover_models$learners[[x]]$model$tuning_instance$best()$prediction()$data$tab %>% 
        mutate(row_id = paste0(row_id, "_", row_ids)))
  
  imp <- data.frame(cover_models$learners[[x]]$learner$model$regr.ranger$model$variable.importance) %>% 
    rownames_to_column() %>% 
    dplyr::rename_at(vars(names(.)), ~c("layer", "importance")) %>% 
    arrange(desc(importance))
  
  out <- utils::capture.output(cover_models$learners[[x]]$learner$model$regr.ranger$model)
  best_model <- cover_models$learners[[x]]$learner$model$regr.ranger$model
  
  write.csv(tune_results, file = file.path(dir_out, paste0(x, "_tune_results.csv")),
            row.names = FALSE)
  cat(out, file = file.path(dir_out, paste0(x, "_model.txt")), append = TRUE)
  save(best_model, file = file.path(dir_out, paste0(x, "_model.RData")))
  write.csv(test_data, file = file.path(dir_out, paste0(x, "_model_resampling.csv")), 
            row.names = FALSE)
  write.csv(imp, file.path(dir_out, paste0(x, "_cover_var_importance.csv")), 
            row.names = FALSE)
  write.csv(cover[[x]], file.path(dir_out, paste0(x, "_input_data.csv")), 
            row.names = FALSE)
  
  return(list(
    tune_results = tune_results,
    best_model = best_model, 
    resampling = test_data,
    importance = imp
  ))
  
}, simplify = FALSE, USE.NAMES = TRUE)

# Run the map predictions
cover_predictions <- sapply(names(cover_models$learners), function(x) {
  
  dir_out <- file.path(output_dir, "cover_predictions", x)
  dir.create(dir_out, showWarnings = FALSE)
  cov_sub <- subset(cov_raster, cover_models$tasks[[x]]$col_roles$feature)
  
  out <- predict_landscape_mlr3(
    learner = cover_models$learners[[x]],
    task = cover_models$tasks[[x]], 
    type = "response",
    covariates = cov_sub,
    tilesize = 500, 
    outDir = tile_dir, 
    mask_layer = mask_layer$layer
  )
  
  # with predict_landscape_mlr3 type set to "response", the output is a single raster image
  writeRaster(
    out, 
    file.path(dir_out, paste0(x, "_cover.tif")), 
    overwrite = TRUE)
  
  return(out)
  
}, simplify = FALSE, USE.NAMES = TRUE)

```



```{r Zonal statistics}

# Using the dsmart TEM as the zonal layer, run zonal statistics for each map model
site_series_t <- terra::rast(file.path(ss_dir, grep(ss, basename(site_series), value = TRUE)))
dsmart_lookup <- read.csv(file.path(ss_dir, "lookup.txt"))

pres_zonal <- sapply(list.dirs(
  file.path(output_dir, "pres_abs_predictions"), 
  full.names = FALSE)[-1], function(x) {
    
    t <- rast(file.path(output_dir, "pres_abs_predictions", x, paste0(x, "_TRUE..tif")))
    zonal_stats <- cbind(
      zonal(t, site_series_t, fun = "mean", na.rm = TRUE), 
      min = zonal(t, site_series_t, fun = "min", na.rm = TRUE)[, names(t)], 
      max = zonal(t, site_series_t, fun = "max", na.rm = TRUE)[,  names(t)],
      sd = zonal(t, site_series_t, fun = "sd", na.rm = TRUE)[,  names(t)]) %>% 
      merge(dsmart_lookup, by.x = "zone", by.y = "code") %>% 
      dplyr::rename_at(vars(names(t), name), ~c("mean", "site_series")) %>% 
      dplyr::select(site_series, mean, min, max, sd)
    
    write.csv(zonal_stats, file.path(
      output_dir, "pres_abs_predictions", x, paste0(x, "_pres_abs_zonal_stats.csv")), 
      row.names = FALSE)
    return(zonal_stats)
  }, simplify = FALSE, USE.NAMES = TRUE
)

cover_zonal <- sapply(list.dirs(
  file.path(output_dir, "cover_predictions"), 
  full.names = FALSE)[-1], function(x) {
    
    t <- rast(file.path(output_dir, "cover_predictions", x, paste0(x, "_cover.tif")))
    zonal_stats <- cbind(
      zonal(t, site_series_t, fun = "mean", na.rm = TRUE), 
      min = zonal(t, site_series_t, fun = "min", na.rm = TRUE)[, names(t)], 
      max = zonal(t, site_series_t, fun = "max", na.rm = TRUE)[,  names(t)],
      sd = zonal(t, site_series_t, fun = "sd", na.rm = TRUE)[,  names(t)]) %>% 
      merge(dsmart_lookup, by.x = "zone", by.y = "code") %>% 
      dplyr::rename_at(vars(names(t), name), ~c("mean", "site_series")) %>% 
      dplyr::select(site_series, mean, min, max, sd)
    
    write.csv(
      zonal_stats, 
      file.path(output_dir, "cover_predictions", x, paste0(x, "_cover_zonal_stats.csv")), 
      row.names = FALSE)
    return(zonal_stats)
  }, simplify = FALSE, USE.NAMES = TRUE
)

```



```{r ModelMap testing}

important_vars <- names(model_ranger$variable.importance)
mmap_test <- model.build(
  model.type = "RF",
  qdata.trainfn = raw_data[, c("response", important_vars)], 
  folder = tempdir(),
  MODELfn = NULL,
  predList = names(raw_data[, c("response", important_vars)])[-1],
  predFactor = c("Structural.Stage", "Site.Disturbance"),
  response.name = names(raw_data)[1], 
  response.type = "categorical", 
  unique.rowname = FALSE,
  ntree = model_ranger$num.trees, 
  mtry = model_ranger$mtry, 
  proximity = FALSE
)

write.csv(mmap_test$confusion, file.path(output_dir, paste0(model_run, "_MMap_confusion.csv")))

```

